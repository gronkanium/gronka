image: node:20

stages:
  - validate
  - test:utils
  - test:commands
  - test:scripts
  - test:integration
  - release

# Reusable YAML anchors
.default_rules: &default_rules
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - src/**/*
        - test/**/*
        - scripts/**/*
        - package.json
        - package-lock.json
        - .env.example
        - eslint.config.js
        - vite.config.js
        - svelte.config.js
        - docker-compose*.yml
        - Dockerfile
        - .gitlab-ci.yml
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
      changes:
        - src/**/*
        - test/**/*
        - scripts/**/*
        - package.json
        - package-lock.json
        - .env.example
        - eslint.config.js
        - vite.config.js
        - svelte.config.js
        - docker-compose*.yml
        - Dockerfile
        - .gitlab-ci.yml

.default_cache: &default_cache
  cache:
    paths:
      - node_modules/
    key: ${CI_COMMIT_REF_SLUG}

.postgres_service: &postgres_service
  services:
    - name: postgres:16-alpine
      variables:
        POSTGRES_DB: gronka_test
        POSTGRES_USER: gronka
        POSTGRES_PASSWORD: gronka

.test_variables: &test_variables
  variables:
    DISCORD_TOKEN: 'ci-test-token'
    CLIENT_ID: 'ci-test-client-id'
    POSTGRES_DB: gronka_test
    POSTGRES_USER: gronka
    POSTGRES_PASSWORD: gronka
    POSTGRES_HOST: postgres
    POSTGRES_PORT: '5432'

.wait_for_postgres: &wait_for_postgres
  - apt-get update -qq && apt-get install -y -qq postgresql-client
  - |
    MAX_WAIT=60
    ELAPSED=0
    until PGPASSWORD=$POSTGRES_PASSWORD psql -h $POSTGRES_HOST -U $POSTGRES_USER -d $POSTGRES_DB -c '\q' 2>/dev/null; do
      if [ $ELAPSED -ge $MAX_WAIT ]; then
        echo "ERROR: PostgreSQL did not become ready in $MAX_WAIT seconds"
        exit 1
      fi
      echo "Waiting for PostgreSQL... ($ELAPSED/$MAX_WAIT seconds)"
      sleep 2
      ELAPSED=$((ELAPSED + 2))
    done
    echo "PostgreSQL is ready!"

# Validate stage
validate-code:
  stage: validate
  <<: *default_rules
  <<: *default_cache
  variables:
    DISCORD_TOKEN: 'ci-test-token'
    CLIENT_ID: 'ci-test-client-id'
  script:
    - npm ci
    - npm run validate

# Test stages
test-utils:
  stage: test:utils
  <<: *postgres_service
  <<: *default_rules
  <<: *test_variables
  <<: *default_cache
  script:
    - *wait_for_postgres
    - npm ci
    - npx cross-env R2_ACCOUNT_ID= R2_ACCESS_KEY_ID= R2_SECRET_ACCESS_KEY= R2_BUCKET_NAME= node --test test/utils/

test-commands:
  stage: test:commands
  <<: *postgres_service
  <<: *default_rules
  <<: *test_variables
  <<: *default_cache
  script:
    - *wait_for_postgres
    - npm ci
    - npx cross-env R2_ACCOUNT_ID= R2_ACCESS_KEY_ID= R2_SECRET_ACCESS_KEY= R2_BUCKET_NAME= node --test test/commands/

test-scripts:
  stage: test:scripts
  <<: *postgres_service
  <<: *default_rules
  <<: *test_variables
  <<: *default_cache
  script:
    - *wait_for_postgres
    - npm ci
    - npx cross-env R2_ACCOUNT_ID= R2_ACCESS_KEY_ID= R2_SECRET_ACCESS_KEY= R2_BUCKET_NAME= node --test test/scripts/

test-integration:
  stage: test:integration
  <<: *postgres_service
  <<: *default_rules
  <<: *test_variables
  <<: *default_cache
  script:
    - *wait_for_postgres
    - npm ci
    - npx cross-env R2_ACCOUNT_ID= R2_ACCESS_KEY_ID= R2_SECRET_ACCESS_KEY= R2_BUCKET_NAME= node --test test/webui-server-*.test.js test/docker-security.test.js

# Release stage
create-release:
  stage: release
  image: docker:24
  services:
    - docker:24-dind
  rules:
    - if: $CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+$/
  variables:
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: '/certs'
  before_script:
    - apk add --no-cache nodejs npm git bash curl jq
    - |
      # Wait for Docker daemon
      MAX_RETRIES=30
      RETRY_COUNT=0
      while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
        if docker info >/dev/null 2>&1; then
          echo "Docker daemon is ready!"
          break
        fi
        RETRY_COUNT=$((RETRY_COUNT + 1))
        echo "Waiting for Docker... ($RETRY_COUNT/$MAX_RETRIES)"
        sleep 2
      done
      if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
        echo "ERROR: Docker daemon failed to start"
        exit 1
      fi
    - |
      # Docker login
      MAX_RETRIES=5
      RETRY_COUNT=0
      while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
        if docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY 2>&1; then
          echo "Logged in to registry"
          break
        fi
        RETRY_COUNT=$((RETRY_COUNT + 1))
        echo "Login retry ($RETRY_COUNT/$MAX_RETRIES)"
        sleep 2
      done
      if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
        echo "ERROR: Failed to login"
        exit 1
      fi
    - |
      TAG_NAME=$CI_COMMIT_TAG
      VERSION=${TAG_NAME#v}
      echo "VERSION=$VERSION" >> build.env
      echo "TAG_NAME=$TAG_NAME" >> build.env
  script:
    - source build.env
    - |
      # Verify version matches package.json
      PACKAGE_VERSION=$(node -p "require('./package.json').version")
      if [ "$PACKAGE_VERSION" != "$VERSION" ]; then
        echo "Error: Tag version ($VERSION) does not match package.json ($PACKAGE_VERSION)"
        exit 1
      fi
    - |
      # Generate release notes
      if [ -f "CHANGELOG.md" ]; then
        NOTES=$(awk "/^## \[?$VERSION\]?/,/^## /" CHANGELOG.md | head -n -1 || echo "See CHANGELOG.md")
      else
        NOTES="Release $TAG_NAME"
      fi
      if [ -z "$NOTES" ]; then
        PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
        if [ -n "$PREV_TAG" ]; then
          NOTES=$(git log ${PREV_TAG}..HEAD --pretty=format:"- %s" --no-merges || echo "Release $TAG_NAME")
        fi
      fi
      echo "$NOTES" > release_notes.txt
      echo -e "\n## Installation\n\n### Docker\n\`\`\`bash\ndocker pull $CI_REGISTRY_IMAGE:$VERSION\n\`\`\`" >> release_notes.txt
    - |
      # Create source archive
      ARCHIVE_NAME="gronka-$VERSION.tar.gz"
      tar --exclude='.git' --exclude='node_modules' --exclude='data' --exclude='temp' --exclude='logs' -czf "$ARCHIVE_NAME" .
      sha256sum "$ARCHIVE_NAME" > "${ARCHIVE_NAME}.sha256"
    - |
      # Build and push Docker image
      apk add --no-cache docker-cli-buildx || true
      docker buildx create --use --name builder || docker buildx use builder || true
      docker buildx build \
        --platform linux/amd64 \
        --tag $CI_REGISTRY_IMAGE:$VERSION \
        --tag $CI_REGISTRY_IMAGE:latest \
        --push \
        --cache-from type=registry,ref=$CI_REGISTRY_IMAGE:latest \
        --cache-to type=inline \
        .
    - |
      # Create release via API
      RELEASE_DESC=$(cat release_notes.txt | jq -Rs .)
      curl --request POST \
           --header "JOB-TOKEN: $CI_JOB_TOKEN" \
           --header "Content-Type: application/json" \
           --data "{
             \"name\": \"Release ${CI_COMMIT_TAG}\",
             \"tag_name\": \"${CI_COMMIT_TAG}\",
             \"description\": ${RELEASE_DESC},
             \"assets\": {
               \"links\": [
                 {\"name\": \"Source Archive\", \"url\": \"${CI_JOB_URL}/artifacts/raw/gronka-$VERSION.tar.gz\"},
                 {\"name\": \"SHA256 Checksum\", \"url\": \"${CI_JOB_URL}/artifacts/raw/gronka-$VERSION.tar.gz.sha256\"}
               ]
             }
           }" \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/releases" || echo "Release may already exist"
  artifacts:
    paths:
      - gronka-*.tar.gz
      - gronka-*.tar.gz.sha256
      - release_notes.txt
    expire_in: 1 week
